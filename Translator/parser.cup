/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            COM, PLUS, LPAREN, RPAREN, LBRA, RBRA, IFSYM, ELSESYM, PREFIX, SUFFIX;
terminal String     STRINGL,IDENT ;        // our scanner provides numbers as strings

/*  Non terminals */
non terminal String 	prog,defs,def,call,calls,args,argsRec,val,code_,ifstm,cond,conds,oper,expr,exprs;

/**
 *  Precedence Declarations
 */
precedence left PLUS;

/**
 *  The Grammar Rules
 */

prog 	::= defs:d calls:c 					{: System.out.println("public class Main {\npublic static void main(String[] args) {\n" + c + "\n}" + d + "\n}"); :}
			;

defs	::= defs:ds def:d 	 				{: RESULT = ds + d; :}
			|								{: RESULT = ""; :}
			;

def 	::= IDENT:id LPAREN args:ar RPAREN LBRA code_:cd RBRA	
											{: String words[]=ar.split(",");StringBuffer buf = new StringBuffer();
											   for(int i=0;i<words.length;i++){buf.append(" String "+words[i]);if(i!=words.length-1){buf.append(",");}}
											   RESULT = "\npublic static String " + id + "(" + buf.toString() + " ){" + cd + "\n}"; :}
			|IDENT:id LPAREN RPAREN LBRA code_:cd RBRA 	
											{: RESULT = "\npublic static String " + id + "( ){" + cd + "\n}"; :}
			;

calls 	::= call:c calls:cs 				{: RESULT = c + cs ; :}
			|								{: RESULT = ""; :}
			;

call 	::= IDENT:id LPAREN args:ar RPAREN 	{: RESULT = "\nSystem.out.println(" + id + "( " + ar + "));"; :}
			|IDENT:id LPAREN RPAREN 		{: RESULT = "\nSystem.out.println(" + id + "( ));"; :}
			;

args 	::= expr:ex argsRec:ar				{: RESULT = ex + ar; :} 						
			;

argsRec 	::= COM expr:ex argsRec:ar 		{: RESULT = "," + ex + ar; :}
			| 								{: RESULT = ""; :}
			;

val 	::= call:cl 						{: RESULT = cl; :}
			|STRINGL:str					{: RESULT = "\""+str+"\""; :}
			|ifstm:ifst 					{: RESULT = ifst; :}
			;

code_ 	::= expr:xp 						{: RESULT = "\nreturn " + xp + ";"; :}	
			| 								{: RESULT = "\nreturn \"\";"; :}
			;

ifstm 	::= IFSYM LPAREN cond:cn RPAREN code_:c1 ELSESYM code_:c2
											{: RESULT = "\nif( "+cn+" ) {\n"+c1 +"\n} else {\n"+c2+"\n}"; :}
			;

cond 	::= val:v conds:c   				{: RESULT = v + c; :}
			|IDENT:v conds:c   				{: RESULT = v + c; :}
			;

conds 	::= oper:op val:vl conds:c   		{: RESULT = op + vl + c; :}
			|oper:op IDENT:vl conds:c   	{: RESULT = op + vl + c; :}
			| 								{: RESULT = "" ; :}
			;

oper 	::= PREFIX 		 					{: RESULT = " pref "; :} 
			|SUFFIX 	 					{: RESULT = " suffix "; :}
			;

expr 	::= val:vl exprs:exp 				{: RESULT =  vl + exp ;:}
			|IDENT:id exprs:exp 			{: RESULT =  id + exp ;:}
			;

exprs 	::= PLUS val:vl exprs:exp 			{: RESULT = " + " + vl + exp; :}
			|PLUS IDENT:nm exprs:exp 		{: RESULT = " + " + nm + exp; :}
			| 								{: RESULT = "" ; :}
			;