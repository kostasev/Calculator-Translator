/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            COM, PLUS, LPAREN, RPAREN, LBRA, RBRA, IFSYM, ELSESYM, PREFIX, SUFFIX;
terminal String     STRINGL,IDENT ;        // our scanner provides numbers as strings

/*  Non terminals */
non terminal String 	prog,defs,def,calls,call,argsC,argsC2,val,code1,ifstm,cond,conds,oper,expr,exprs;

/**
 *  Precedence Declarations
 */
precedence left PLUS;

/**
 *  The Grammar Rules
 */

prog 	::= defs:dfs calls:clls 								{: System.out.println("public class Main {\n" + clls + dfs + "\n}"); :}
			;

defs	::= defs:dfs def:df 									{: RESULT = df + dfs; :}
			|													{: RESULT = ""; :}
			;

def 	::= IDENT:nm LPAREN argsC:rgs1 RPAREN LBRA code1:cd RBRA	{: String words[]=rgs1.split(",");
																	RESULT = "\npublic static String " + nm + "( " + words[0] + " ){ " + cd + "\n}"; :}
			|IDENT:nm LPAREN RPAREN LBRA code1:cd RBRA 	{: RESULT = "\npublic static String " + nm + "( ){ " + cd + "\n}"; :}
			;
calls 	::= call:cl calls:cls 									{: RESULT = cl + cls; :}
			//|call:cl 											{: RESULT = cl; :}
			|													{: RESULT = ""; :}
			;

call 	::= IDENT:nm LPAREN argsC:rgs RPAREN 					{: RESULT = "\n\tSystem.out.println(" + nm + "( "+rgs+"));"; :}
			|IDENT:nm LPAREN RPAREN 					{: RESULT = "\n\tSystem.out.println(" + nm + "( ));"; :}
			;
/*
argsD 	::= IDENT:nm argsD2:rgsD									{: RESULT = "String " + nm + rgsD; :}
			;
argsD2	::= COM IDENT:nm argsD2:rgsD 							{: RESULT = ", String " + nm + rgsD; :}
			| 													{: RESULT = ""; :}
			;
*/
argsC 	::= expr:vl argsC2:rgsC								{: RESULT = vl + ","+ rgsC; :} 						
			//|expr:vl argsC2:rgsC								{: RESULT = vl + ","+ rgsC; :}
			;
argsC2 	::= COM expr:vl argsC2:rgsC								{: RESULT = vl + ","+ rgsC; :}
			//|COM expr:vl argsC2:rgsC								{: RESULT = vl + ","+ rgsC; :}
			| 													{: RESULT = ""; :}
			;
val 	::= call:cl 											{: RESULT = cl; :}
			|STRINGL:s 										{: RESULT = "\"" + s + "\""; :}
			|ifstm:ifst 										{: RESULT = ifst; :}
			;

//IDENT 	::= IDENT:id 											{: RESULT = id ; :}
//			;

code1 	::= //IDENT:nm 											{: RESULT = "return " + nm +";"; :}
			 expr:xp 											{: RESULT = "return (" + xp + ");"; :}	
			//| val:vl 											{: RESULT = "return " + vl +" ;" ; :}
			| 													{: RESULT = "return \"\";"; :}
			;

ifstm 	::= IFSYM LPAREN cond:cnd RPAREN code1:cd1 ELSESYM code1:cd2
																{: RESULT = "if( "+cnd+"){\n"+cd1 +"\n}" + "else {"+cd2+"\n}"; :}
			;
cond 	::= val:vl conds:cnds   								{: RESULT = vl + cnds; :}
			|IDENT:vl conds:cnds   								{: RESULT = vl + cnds; :}
			; 
conds 	::= oper:op val:vl conds:cnds   						{: RESULT = op + vl + cnds; :}
			|oper:op IDENT:vl conds:cnds   						{: RESULT = op + vl + cnds; :}
			| 													{: RESULT = "" ; :}
			;
oper 	::= PREFIX:pref 										{: RESULT = "pref "; :} 
			|SUFFIX:suf 										{: RESULT = "suffix "; :}
			;


expr 	::= val:vl exprs:exp 									{: RESULT =  vl + exp ;:}
			|IDENT:nm exprs:exp
			;
exprs 	::= PLUS val:vl exprs:exp 							{: RESULT = " + " + vl + exp; :}
			|PLUS IDENT:nm exprs:exp 						{: RESULT = " + " + nm + exp; :}
			| 													{: RESULT = "" ; :}
			;